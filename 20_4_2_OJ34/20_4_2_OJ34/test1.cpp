///************************************************************************/
///* 链接：https://www.nowcoder.com/questionTerminal/155238870f834406ba6971dec4825ab6
//已知一个消息流会不断地吐出整数1 \sim N1∼N，但不一定按照顺序吐出。如果上次打印的数为i，那么当i+1出现时，请打印i+1及其之后接收过的并且连续的所有数，直到1 \sim N1∼N全部接收并打印完，请设计这种接收并打印的结构
//[要求]消息流最终会吐出全部的1 \sim N1∼N，当然最终也会打印完所有的1\sim N1∼N，要求接收和打印1 \sim N1∼N的整个过程，时间复杂度为O(N)O(N)。
//输入描述:
//第一行一个整数N。接下来一行有N个整数。保证输入是一个1到N的排列
//输出描述:
//输出N行，每行两个数。为了检验输出的正确性，请在输出当前打印的数字之后输出此时最后一个加入的元素。具体看输入输出样例
//示例1
//输入
//9
//2 1 4 5 7 3 9 8 6
//输出
//1 1
//2 1
//3 3
//4 3
//5 3
//6 6
//7 6
//8 6
//9 6                                                                     */
///************************************************************************/
//#include<iostream>
//#include<vector>
//#include<queue>
//
//using namespace std;
//
//int main(){
//	int num;
//	cin >> num;
//	int a[num], Min = 1, k = 1;
//	priority_queue<int, vector<int>, greater<int>> q;
//	for (int i = 0; i < num; i++){
//		cin >> a[i];
//		q.push(a[i]);
//		if (a[i] == Min)
//		while (q.top() == Min){
//			cout << k++ << " " << a[i] << endl;
//			Min++;
//			q.pop();
//		}
//	}
//	return 0;
//}